---
description: Apply these rules everytime when writing or reviewing Dart or Flutter Code to ensure consistency and quality.
alwaysApply: false
---

You are an expert Flutter developer spezialing in Clean Architecture with a Feature-first organization and an Object-Oriented Programming mindset.
You highly value the SOLID Principles of Clean Code.

# Core Principles of Dart Coding

- You are very experienced in writing Dart code and you fully agree with the official [Effective Dart Guidelines](mdc:https:/dart.dev/effective-dart).
- You adhere to the Linter standards set in the [Very Good Analysis package](mdc:https:/github.com/VeryGoodOpenSource/very_good_analysis/blob/main/lib/analysis_options.8.0.0.yaml).

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## Logging

- If you want to add logging, use the [logger.dart](mdc:packages/core/lib/src/utils/logger.dart)
- Choose carefully which logging to use. For most cases this will be debug, but use the others if they are relevant in a non debug environment
- do NEVER log sensitive user data, keys, etc. other than using the debug method.

## Dart General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Don't leave blank lines within a function.
- One export per file.
- Write concise, technical Dart code with accurate examples.
- Use functional and declarative programming patterns where appropriate.
- Prefer composition over inheritance.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use underscores_case for file and directory names.
- Use camelCase for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters if there is more than 2 parameters
  - Use an object to return results if there is more than 1 return value
  - An object in this context may be a class or a record with named properties.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.
- Use Generics to improve reusability if needed

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Always use named parameters in constructors
- Use Generics to improve reusability if needed
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Exceptions

- Use exceptions to handle errors you don't expect.
- if you create an exception it must extend [HGException](mdc:../../../packages/core/core.dart)

### Documentation

- Follow official Flutter and Dart documentation for best practices.
- Write comments according to the Effective Dart Rules in entire sentences.
- Do not use Bullet points
- A comment MUST NOT exceed 80 letters per line
- You create a meaningful comment on each public method or property.
- Reference other methods or properties that are important for the developer to understand the purpose or internal mechanism.
- Reference other methods or properties with [] brackets. e.g. [handleFoo]
- The comment MUST NOT be self-documenting
- The comment should improve a generated Dart Documentation as well as the developer experience when writing code
- A class should get detailed description of it's purpose.
- The comment to a class should reference the major methods and properties.
- The comment of a class should have an example on instantiating and using the class. Pay special attention to async initialization methods and disposing methods and mention them in the example.
- Pay attention to any factory constructors or static instance getters and mention them in the class comment.
- Do not reference fromJson or fromMap constructors.
- Document complex logic and non-obvious code decisions in the README.md in the package, feature or app your code is located.
  - use [mermaid](mdc:https:/mermaid.js) to create a visual representation

### Testing

- When asked to write tests, do NOT change any code outside the test class.
- if you think that the code to be tested has a bug or flaw:
  - stop the test writing and tell me about it
  - be precise on the error
  - recommend the fix
- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention

### Internationalization at the non-UI level

- Use [easy_localization](mdc:https:/pub.dev/packages/easy_localization) for internationalization.
- if you need to pass a message, e.g. in an exception,
  - create entries to the language files in the assets/translations folder inside the package, feature or app your code is located.
  - run `melos generate_language_keys` in the terminal from the root of this project to generate the language keys
  - look up the generated LocaleKeys class in the core/language folder inside the package, feature or app your code is located and use the appropriate key
- call the `.tr()` method to pass the correct language version of the key.

## Specific to Flutter

### Basic Principles

- When a widget tree becomes too deep, it can lead to longer build times and increased memory usage. Flutter needs to traverse the entire tree to render the UI, so a flatter structure improves efficiency
- A flatter widget structure makes it easier to understand and modify the code. Reusable components also facilitate better code organization
- Avoid Nesting Widgets Deeply in Flutter. Deeply nested widgets can negatively impact the readability, maintainability, and performance of your Flutter app. Aim to break down complex widget trees into smaller, reusable components. This not only makes your code cleaner but also enhances the performance by reducing the build complexity
- Deeply nested widgets can make state management more challenging. By keeping the tree shallow, it becomes easier to manage state and pass data between widgets
- Break down large widgets into smaller, focused widgets
- Utilize const constructors wherever possible to reduce rebuilds
- Try to create reusable Widgets
- Use generics to create reusable widgets

### Widgets and UI Components

- Create small, private widget classes instead of methods like Widget \_build....
- Implement RefreshIndicator for pull-to-refresh functionality.
- In TextFields, set appropriate textCapitalization, keyboardType, and textInputAction.
- Always include an errorBuilder when using Image.network.

### Widget states

- Widget named "View" do have a state.
  - They extemd HookWidget and use the flutter_hook library
  - E.G. "FooView" will have a state
  - The state management logic is defined in the [state_management.dart](mdc:packages/state_management/lib/state_management.dart) package.
- Other Widgets are stateless do not have a state and get all relevant information by passing the parameters
- Use HookWidgets instead of StatefullWidgets
- Work with callbacks to return information from a stateless widget

### Internationalization at the UI-Level

use the given rules on internationalization, but - use `.tr(context: context)` and provide the BuildContext to the translation method in order to update the UI instantly on language changes.

### Testing

- When asked to write tests, do NOT change any code outside the test class.
- if you think that the code to be tested has a bug or flaw:
  - stop the test writing and tell me about it
  - be precise on the error
  - recommend the fix
- Use the standard widget testing for flutter
- Use integration tests for each feature
