// // AUTOGENERATED - DO NOT MODIFY MANUALLY

import 'package:cached/cached.dart';
import 'src.dart';

@Entity()
class CachedInfo with HashMixin {
  CachedInfo({
    this.firstName,
    required this.lastName,
    required this.id,
    required this.databaseId,
  });

  factory CachedInfo.fromModel(Info model) {
    return CachedInfo(
      firstName: model.firstName,
      lastName: model.lastName,
      id: model.id,
      databaseId: model.databaseId,
    );
  }

  String? firstName;

  @Index()
  String lastName;

  @Unique(onConflict: ConflictStrategy.replace)
  String id;

  @Id()
  int databaseId;

  final userWithInfos = ToOne<CachedUserWithInfos>();

  Info toModel() {
    return Info(
      firstName: firstName,
      lastName: lastName,
      id: id,
      databaseId: databaseId,
    );
  }

  void remove(Store store) {
    // if databaseId is 0 the model
    // has not been saved to the database yet
    if (databaseId == 0) {
      return;
    }

    // remove this
    store.box<CachedInfo>().remove(databaseId);
  }
}

@Entity()
class CachedUser with HashMixin {
  CachedUser({this.name, required this.id, required this.databaseId});

  factory CachedUser.fromModel(User model) {
    final cached = CachedUser(
      name: model.name,
      id: model.id,
      databaseId: model.databaseId,
    );

    return cached;
  }

  var info = ToOne<CachedInfo>();

  String? name;

  @Unique(onConflict: ConflictStrategy.replace)
  String id;

  @Id()
  int databaseId;

  User toModel() {
    return User(
      name: name,
      id: id,
      databaseId: databaseId,
      info: info.target?.toModel(),
    );
  }

  void remove(Store store) {
    // if databaseId is 0 the model
    // has not been saved to the database yet
    if (databaseId == 0) {
      return;
    }

    final entry = store.box<CachedUser>().get(databaseId);

    // remove info
    if (entry?.info.targetId != null) {
      store.box<CachedInfo>().remove(entry!.info.targetId);
    }

    // remove this
    store.box<CachedUser>().remove(databaseId);
  }
}

@Entity()
class CachedUserWithInfos with HashMixin {
  CachedUserWithInfos({required this.id, required this.databaseId, this.name});

  factory CachedUserWithInfos.fromModel(UserWithInfos model) {
    final cached = CachedUserWithInfos(
      id: model.id,
      databaseId: model.databaseId,
      name: model.name,
    );

    for (final el in model.infos) {
      final embeddedElement = CachedInfo.fromModel(el);
      cached.infos.add(embeddedElement);
    }

    return cached;
  }

  @Unique(onConflict: ConflictStrategy.replace)
  String id;

  @Id()
  int databaseId;

  @Backlink('userWithInfos')
  var infos = ToMany<CachedInfo>();

  String? name;

  UserWithInfos toModel() {
    return UserWithInfos(
      id: id,
      databaseId: databaseId,
      name: name,
      infos: infos.map((e) => e.toModel()).toList(),
    );
  }

  void remove(Store store) {
    // if databaseId is 0 the model
    // has not been saved to the database yet
    if (databaseId == 0) {
      return;
    }

    List<int> fieldIds = [];

    // remove infos
    fieldIds = infos.map((e) => e.databaseId).toList();
    store.box<CachedInfo>().removeMany(fieldIds);

    // remove this
    store.box<CachedUserWithInfos>().remove(databaseId);
  }
}
